# -*- coding: utf-8 -*-
"""syntax lstm di pakai.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cfN6_XGhlzsaa9VNA5rECxI4EF7WpOH7
"""

import  numpy  as  np
import  pandas  as  pd
from  tensorflow.keras.models  import  Sequential
from  tensorflow.keras.layers  import  LSTM ,  Dense
from  sklearn.model_selection  import  train_test_split
from  sklearn.preprocessing  import  MinMaxScaler
import  matplotlib.pyplot  as  plt
from  tensorflow.keras.optimizers  import  Adam

excel_file=pd.read_excel('/content/Data Asli.xlsx')

#Melakukan interpolasi
df_interpol=excel_file.interpolate()
df_interpol

df = pd.read_excel('/content/Data Interpolasi Linear.xlsx')
df

import numpy as np
import tensorflow as tf
import random as python_random

# Menetapkan seed
np.random.seed(42)
python_random.seed(42)
tf.random.set_seed(42)

values = df['RR'].values.reshape(-1, 1)
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_values = scaler.fit_transform(values)

def create_dataset(dataset, look_back=1):
    X, Y = [], []
    for i in range(len(dataset) - look_back):
        a = dataset[i:(i + look_back), 0]
        X.append(a)
        Y.append(dataset[i + look_back, 0])
    return np.array(X), np.array(Y)

look_back = 1 # Menggunakan data dari 1 hari sebelumnya untuk memprediksi hari berikutnya
X, Y = create_dataset(scaled_values, look_back)

# Ubah input menjadi [samples, time steps, features]
X = np.reshape(X, (X.shape[0], look_back, 1))

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=42, shuffle=False)

model = Sequential([
    LSTM(50, input_shape=(X_train.shape[1], X_train.shape[2]),return_sequences=True
    ),
    LSTM(50,return_sequences=True),
    LSTM(50),
       Dense(1)
])
model.compile(optimizer=Adam(learning_rate=0.01), loss='mean_squared_error')

# Latih model
model.fit(X_train, Y_train, epochs=30, batch_size=32, validation_data=(X_test, Y_test), verbose=2)

# Mengakses layer LSTM pertama
lstm_layer_1 = model.layers[0]

# Mendapatkan bobot dari layer LSTM pertama
weights, recurrent_weights, bias = lstm_layer_1.get_weights()

# Bobot ini merupakan numpy arrays
# weights: Bobot untuk input
# recurrent_weights: Bobot untuk recurrent connection
# bias: Bias

print("Bobot untuk input:", weights.shape)
print("Bobot untuk recurrent connection:", recurrent_weights.shape)
print("Bias:", bias.shape)

weight=model.get_weights()
weight

# Membuat prediksi
train_predict = model.predict(X_train)
test_predict = model.predict(X_test)

# Invers transformasi skala
train_predict = scaler.inverse_transform(train_predict)
Y_train_inv = scaler.inverse_transform([Y_train])
test_predict = scaler.inverse_transform(test_predict)
Y_test_inv = scaler.inverse_transform([Y_test])

from sklearn.metrics import mean_absolute_error

# Menghitung MAE untuk data latih
mae_train = mean_absolute_error(Y_train_inv.flatten(), train_predict.flatten())
print(f"MAE untuk data latih: {mae_train}")

mae_test = mean_absolute_error(Y_test_inv.flatten(), test_predict.flatten())
print(f"MAE untuk data uji: {mae_test}")

from sklearn.metrics import mean_squared_error
import numpy as np

# Menghitung MSE terlebih dahulu
mse_train = mean_squared_error(Y_train_inv.flatten(), train_predict.flatten())
mse_test = mean_squared_error(Y_test_inv.flatten(), test_predict.flatten())

# Menghitung RMSE dengan mengambil akar kuadrat dari MSE
rmse_train = np.sqrt(mse_train)
rmse_test = np.sqrt(mse_test)

print(f"RMSE untuk data latih: {rmse_train}")
print(f"RMSE untuk data uji: {rmse_test}")

# Prediksi untuk hari berikutnya
last_input = scaled_values[-look_back:]
# Reshape last_input sesuai dengan format yang dibutuhkan oleh LSTM: [samples, time steps, features]
next_day_pred_scaled = model.predict(np.reshape(last_input, (1, look_back, 1)))
next_day_pred = scaler.inverse_transform(next_day_pred_scaled)

print(f"Prediksi suhu untuk hari berikutnya: {next_day_pred[0][0]}")

import matplotlib.pyplot as plt

# Plot data asli dan data prediksi untuk data latih
plt.figure(figsize=(10, 5))

# Index untuk plotting
train_index = range(1, len(Y_train_inv[0]) + 1)
test_index = range(len(Y_train_inv[0]) + 1, len(Y_train_inv[0]) + 1 + len(Y_test_inv[0]))


# Plot data testing
plt.plot(test_index, Y_test_inv.flatten(), label='Data Asli - Testing', color='blue' )
plt.plot(test_index, test_predict.flatten(), label='Prediksi - Testing', color='maroon')

plt.legend()
plt.xlabel('Waktu')
plt.ylabel('m/s')
plt.show()

# Siapkan DataFrame untuk menyimpan hasil
pred_df = pd.DataFrame({
    'Prediksi_Train': np.squeeze(train_predict),
    'Y_Train': np.squeeze(Y_train_inv),
    'Prediksi_Test': np.pad(np.squeeze(test_predict), (0, len(Y_train) - len(Y_test)), 'constant', constant_values=np.nan),
    'Y_Test': np.pad(np.squeeze(Y_test_inv), (0, len(Y_train) - len(Y_test)), 'constant', constant_values=np.nan)
})

# Simpan ke CSV
pred_df.to_csv('prediksi_suhu ff_x.csv', index=False)
